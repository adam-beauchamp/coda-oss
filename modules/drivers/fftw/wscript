import os
from waflib import Options
from waflib.TaskGen import feature, before, task_gen
from build import untarFile, handleDefsFile


def options(opt):
    opt.add_option('--with-fft-home', action='store', dest='fft_home',
                   help='Specify the FFT Home - where an FFT library is installed')
    opt.add_option('--with-fftw3-home', action='store', dest='fft3_home',
                   help='Specify the FFT3 Home - where the FFT3 library is installed')
    opt.add_option('--disable-fft', action='store_false', dest='enable_fft',
                   help='turn off building FFT (default)')
    opt.add_option('--enable-fft', action='store_true',
                   default=True, help='turn on FFT')
    opt.add_option('--enable-fft-double', action='store_true', dest='fft_double',
                   default=False, help='turn on double precision FFT')

    # changed this to be the default, so we always build statically
    opt.add_option('--build-fft', action='store_true', dest="build_fft",
                   help='force building FFT library (fftw) from scratch',
                   default=os.path.exists(os.path.join(opt.path.abspath(), 'fftw-2.1.5.tar')))
    opt.add_option('--nobuild-fft', action='store_false', dest="build_fft",
                   help='force not building FFT library (fftw) from scratch')

def configure(conf):
    #-- FFT --------------------------------------------------------------------
    if Options.options.enable_fft:
        fftHome = Options.options.fft_home
        fft3Home = Options.options.fft3_home or os.environ.get('FFT3_HOME', None)
        fftEnv = os.environ.get('FFT_HOME', None)

        # see if they defined env var, but did not set option
        if not fftHome and fftEnv and not Options.options.build_fft:
            fftHome = fftEnv

        if Options.options.fft_double:
            conf.env['MAKE_FFT_DOUBLE'] = True
            conf.env['DEFINES'].append('ENABLE_FFT_DOUBLE=1')
        else:
            conf.env['MAKE_FFT_DOUBLE'] = False

        # FFTW3 - always use fftw3 when available
        if fft3Home:
            if conf.check(lib='fftw3f', uselib_store='FFT',
                          header_name='fftw3.h',
                          function_name='fftwf_execute',
                          libpath=os.path.join(fft3Home, 'lib'),
                          includes=os.path.join(fft3Home, 'include'),
                          msg='Checking for library fftw3', okmsg=fft3Home,
                          mandatory=False):
                conf.env.append_unique('CXXDEFINES_FFT', ['HAVE_FFTW3'])
                conf.define('HAVE_FFTW3', True)

        elif conf.check(lib='fftw3f', uselib_store='FFT',
                        header_name='fftw3.h',
                        function_name='fftwf_execute',
                        msg='Checking for library fftw3',
                        mandatory=False):
            conf.env.append_unique('CXXDEFINES_FFT', ['HAVE_FFTW3'])
            conf.define('HAVE_FFTW3', True)

        # FFTW2 - fallback when fftw3 not available
        elif fftHome:
            if conf.check(lib='fftw', uselib_store='FFT',
                          header_name='fftw.h',
                          function_name='fftw_print_max_memory_usage',
                          libpath=os.path.join(fftHome, 'lib'),
                          includes=os.path.join(fftHome, 'include'),
                          msg='Checking for library fftw2', okmsg=fftHome,
                          mandatory=False):
                conf.env.append_value('LIB_FFT', 'rfftw')

        elif Options.options.build_fft:
            if not os.path.exists(os.path.join(conf.path.abspath(), 'fftw-2.1.5.tar')):
                conf.fatal('Missing fftw tarfile')

            defs = {}

            conf.env['MAKE_FFT'] = True
            conf.env['MAKE_RFFT'] = True
            conf.msg('Building local lib', 'fftw')
            if conf.env['MAKE_FFT_DOUBLE']:
                double_fft = 'yes'
            else:
                double_fft = 'no'
                defs['FFTW_ENABLE_FLOAT'] = '1'
            conf.msg('Building double precision fft library', double_fft)
            
            untarFile(path=conf.path, fname='fftw-2.1.5.tar')
            handleDefsFile(input='fftw/fftw.h.in', output='fftw/fftw.h', defs=defs,
                              path=conf.path.make_node('fftw-2.1.5'))

        elif conf.check(lib='fftw', uselib_store='FFT',
                        header_name='fftw.h',
                        function_name='fftw_print_max_memory_usage',
                        msg='Checking for library fftw2',
                        mandatory=False):
            conf.env.append_value('LIB_FFT', 'rfftw')

def build(bld):
    variant = bld.env['VARIANT']
    env = bld.all_envs[variant]

    driversNode = bld.path

    sourceFiles = []
    
    if 'MAKE_FFT' in env:
        fname = 'fftw-2.1.5'
        
        driverNode = driversNode.make_node(fname)
        
        envDefs = env['DEFINES']
        d, u = {}, []
        for line in envDefs:
            split = line.split('=')
            k = split[0]
            v = len(split) == 2 and split[1] or '1'
            if v:
                d[k] = v
            else:
                u.append(k)

        d['FFTW_VERSION'] = '"2.1.5"'
        if not env['MAKE_FFT_DOUBLE']:
            d['FFTW_ENABLE_FLOAT'] = '1'

        configH = bld(output='fftw/config.h',
                                   path=driverNode,
                                   defs=d,
                                   env=env.derive(),
                                   undefs=u)
        configH.features = ['makeHeader']
        
        #bld.add_group()
        
        #copied from fftw Makefile
        NOTW_CODELETS = 'fn_1.c fn_2.c fn_3.c fn_4.c fn_5.c fn_6.c fn_7.c fn_8.c fn_9.c fn_10.c fn_11.c fn_12.c fn_13.c fn_14.c fn_15.c fn_16.c fn_32.c fn_64.c'
        TWID_CODELETS = 'ftw_2.c ftw_3.c ftw_4.c ftw_5.c ftw_6.c ftw_7.c ftw_8.c ftw_9.c ftw_10.c ftw_16.c ftw_32.c ftw_64.c'
        NOTWI_CODELETS = 'fni_1.c fni_2.c fni_3.c fni_4.c fni_5.c fni_6.c fni_7.c fni_8.c fni_9.c fni_10.c fni_11.c fni_12.c fni_13.c fni_14.c fni_15.c fni_16.c fni_32.c fni_64.c'
        TWIDI_CODELETS = 'ftwi_2.c ftwi_3.c ftwi_4.c ftwi_5.c ftwi_6.c ftwi_7.c ftwi_8.c ftwi_9.c ftwi_10.c ftwi_16.c ftwi_32.c ftwi_64.c'
        OTHERSRC = 'timer.c config.c planner.c twiddle.c executor.c ' \
               'generic.c fftwnd.c malloc.c wisdom.c wisdomio.c putils.c rader.c ' \
                   'fftwf77.c'
        
        if env['CC_NAME'] == 'msvc' and env['LIB_TYPE'] == 'shlib':
            defs = ['BUILD_FFTW_DLL']
        else:
            defs = []
        
        sources = map(lambda s: 'fftw/%s' % s,
                      ' '.join([NOTW_CODELETS, TWID_CODELETS, NOTWI_CODELETS, TWIDI_CODELETS, OTHERSRC]).split())
        fftw = bld(features='c c%s add_targets' % env['LIB_TYPE'] or 'stlib', source=sources,
                                export_includes=['fftw'],
                                target='fftw', path=driverNode,
                                includes=['fftw'],
                                name='FFT', defines=env['DEFINES'] + defs,
                                env=env.derive(), targets_to_add=[configH])

        if env['install_libs']:
            fftw.install_path = env['install_libdir']

        NOTW_CODELETS = 'frc_1.c frc_2.c frc_3.c frc_4.c frc_5.c frc_6.c frc_7.c frc_8.c frc_9.c frc_10.c frc_11.c frc_12.c frc_13.c frc_14.c frc_15.c frc_16.c frc_32.c frc_64.c frc_128.c'
        TWID_CODELETS = 'fhf_2.c fhf_3.c fhf_4.c fhf_5.c fhf_6.c fhf_7.c fhf_8.c fhf_9.c fhf_10.c fhf_16.c fhf_32.c'
        NOTWI_CODELETS = 'fcr_1.c fcr_2.c fcr_3.c fcr_4.c fcr_5.c fcr_6.c fcr_7.c fcr_8.c fcr_9.c fcr_10.c fcr_11.c fcr_12.c fcr_13.c fcr_14.c fcr_15.c fcr_16.c fcr_32.c fcr_64.c fcr_128.c'
        TWIDI_CODELETS = 'fhb_2.c fhb_3.c fhb_4.c fhb_5.c fhb_6.c fhb_7.c fhb_8.c fhb_9.c fhb_10.c fhb_16.c fhb_32.c'
        OTHERSRC = 'rconfig.c rplanner.c rexec.c rexec2.c rfftwnd.c rgeneric.c  rfftwf77.c'
        
        sources = map(lambda s: 'rfftw/%s' % s,
                      ' '.join([NOTW_CODELETS, TWID_CODELETS, NOTWI_CODELETS, TWIDI_CODELETS, OTHERSRC]).split())
        rfftw = bld(features='c c%s add_targets' % env['LIB_TYPE'] or 'stlib', source=sources,
                                export_includes=['fftw', 'rfftw'],
                                target='rfftw', path=driverNode,
                                includes=['fftw', 'rfftw'],
                                use='FFT', name='RFFT',
                                defines=env['DEFINES'] + defs, env=env.derive(),
                                targets_to_add=[configH])
        if env['install_libs']:
            rfftw.install_path = env['install_libdir']
        
        # When building RFFTW as a DLL on Windows we need to include FFTW sources as well.
        if env['CC_NAME'] == 'msvc' and env['LIB_TYPE'] == 'shlib':
            rfftw.source += fftw.source

        if env['install_headers']:
            bld(features='install_tgt', install_path=env['install_includedir'],
                dir=driverNode, files=['fftw/fftw.h', 'rfftw/rfftw.h'],
                name='FFT_HEADERS_INSTALL')
            fftw.targets_to_add += ['FFT_HEADERS_INSTALL']

        if env['install_source']:
            sourceFiles += [fname + '.tar']
            fftw.targets_to_add += ['FFT_SOURCE_INSTALL']

    if env['install_source']:
        sourceNode = driversNode.make_node('source')
        bld.install_tgt(files = sourceFiles,
                        dir = driversNode,
                        install_path = os.path.join('${PREFIX}',
                        sourceNode.path_from(driversNode)),
                        relative_trick=True,
                        name='FFT_SOURCE_INSTALL')

        # TODO: This is a hack to make USELIB_CHECK happy.  Not sure how to
        #       cleanly get around this.
        bld(features = 'install_tgt',
            dir = driversNode,
            name='RFFT_SOURCE_INSTALL')

def distclean(context):
    #remove the untarred directories
    import shutil
    
    dirs = map(lambda d: os.path.join(context.path.abspath(), d),
               ['fftw-2.1.5'])
    for d in dirs:
        try:
            if os.path.exists(d):
                shutil.rmtree(d, ignore_errors=True)
        except:{}
    
