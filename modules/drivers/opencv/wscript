import os, sys, shutil
import re
from waflib import Options, Utils
from build import getPlatform, writeConfig, makeHeaderFile, listToTuple, recursiveGlob
from os.path import join, exists
from zipfile import ZipFile
import types
import md5

from waflib.TaskGen import feature, before_method

version    = 'opencv-3.0.0-rc1'
sourcepath = '%s' % version
zipfile    = '%s.zip' % version

opencv_modules = 'calib3d core features2d flann hal highgui ' +  \
                 'imgcodecs imgproc ml objdetect photo ' +  \
                 'shape stitching superres ts video videoio videostab'

opencv_core_vars = {
    'OPENCV_CUDA_ARCH_BIN' : '',
    'OPENCV_CUDA_ARCH_FEATURES' : '',
    'OPENCV_CUDA_ARCH_PTX' : '',
}

opencv_core_defines = {
    'HAVE_INTTYPES_H': lambda conf: conf.check_cc(header_name='inttypes.h', mandatory=False),
    'WORDS_BIGENDIAN': lambda conf: conf.check_endianness() != 'little',
    # TODO: can we link against this?
    #'HAVE_JPEG': ''
}

gcc_icc_defines = {

}

opencv_compiler_defines = {
    r'gcc' : gcc_icc_defines,
    r'icc' : gcc_icc_defines,
}

opencv_platform_defines = {
    r'win32': {
        'HAVE_WIN32UI': '',
        'HAVE_VFW':  '',
    },
}

def merge_dict(d1, d2):
    if d1:
        out = d1.copy()
        out.update(d2)
    return out


def partition_defines(conf, platform, compiler):
    """Separate defines from undefines"""
    sys_platform = getPlatform(default=platform)

    # look at compiler defs before resorting to platform
    special_defines = None
    for regex in opencv_compiler_defines.keys():
        if re.match(regex, compiler):
            special_defines = opencv_compiler_defines[regex]
            break

    if not special_defines:
        for regex in opencv_platform_defines.keys():
            if re.match(regex, sys_platform):
                special_defines = opencv_platform_defines[regex]
                break

    if not special_defines:
        special_defines = {}

    # merge defines into a single dictionary
    defines = special_defines.copy()
    defines.update(opencv_core_defines)
    
    # partition into defs, undefs
    defs = {}

    remap_bool = lambda val: '' if val else None
    for define, value in defines.iteritems():
        is_def = True
        if isinstance(value, types.FunctionType):
            result = value(conf)
            is_def = result
        else:
            # what was specified is what will go in
            result = value
        if is_def:
            defs[define] = remap_bool(result)
    
    return defs
        

class CMakeConfigHGenerator:

    define_regex     = re.compile(r'#cmakedefine\s+(.*)')
    define_rep_regex = r'#cmakedefine\s+\b%s\b'
    var_regex        = re.compile(r'\${(.*)}')
    var_rep_regex    = r'\${%s}'

    def __init__(self, template_file):
        with open(template_file, 'r') as f:
            self.template_str = f.read()

        # find subsitution candidates
        possible_defines = {}
        def_iter = self.define_regex.finditer(self.template_str)
        for pos_def in def_iter:
            possible_defines[pos_def.group(1)] = None
        self.possible_defines = possible_defines

        # find subsitution candidates
        possible_vars = {}
        var_iter = self.var_regex.finditer(self.template_str)
        for pos_var in var_iter:
            possible_vars[pos_var.group(1)] = None
        self.possible_vars = possible_vars 


    def write(self, path, def_set, var_set):
        def_set_merge = merge_dict(self.possible_defines, def_set)
        var_set_merge = merge_dict(self.possible_vars, var_set)

        # replace #cmakedefine
        out_str = self.template_str
        for define, value in def_set_merge.iteritems():
            if value is None:
                out_str = re.sub(self.define_rep_regex % define,
                                 r'/* #undef %s */' % define, out_str)
            else:
                out_str = re.sub(self.define_rep_regex % define,
                                 r'#define %s %s' % (define, value), out_str)
        

        # replace ${var}
        for var, value in var_set_merge.iteritems():
            if value is None:
                out_str = re.sub(self.var_rep_regex % var, '', out_str)
            else:
                out_str = re.sub(self.var_rep_regex % var, value, out_str)
                
        # dump the contents
        with open(path, 'w') as f:
            f.write(out_str)


def opencv_set_defines(conf, platform):
    sys_platform = getPlatform(default=Options.platform)
    winRegex = r'win32'
    conf.env['DEFINES'].append("__OPENCV_BUILD=1")
    ccCompiler = conf.env['COMPILER_CC']

    # TODO: not cutting it
    conf.undefine('HAVE_OPENCL')

    defs = partition_defines(conf, Options.platform, ccCompiler)

    template_file = conf.path.make_node(join(sourcepath, 'cmake',
                                             'templates', 'cvconfig.h.in'))

    gen = CMakeConfigHGenerator(template_file.abspath())
    gen.write(conf.path.make_node(join(sourcepath, 'cvconfig.h')).abspath(),
              defs, opencv_core_vars)
    

    if ccCompiler == 'gcc' or ccCompiler == 'icc':
        pass
    elif re.match(winRegex, sys_platform):

        # defines
        conf.env['DEFINES'].append('_CRT_NONSTDC_NO_DEPRECATE')
        conf.env['DEFINES'].append('_CRT_SECURE_NO_DEPRECATE')
        conf.env['DEFINES'].append('_VARIADIC_MAX=10')
        conf.env['DEFINES'].append('_WINDOWS')
        # conf.env['DEFINES'].append("WIN32") # done already
        # conf.env['DEFINES'].append("_MBCS") # may be a problem to not define this
        if Options.options.debugging:
            conf.env['DEFINES'].append("_DEBUG")
        else:
            conf.env['DEFINES'].append("NDEBUG")
        addl_flags = '/EHa /fp:precise /Gd /Gm- /GS /Gy /Oi /TP /WX- /Zc:forScope /bigobj'.split()
        # Already done/skippable: /W4 /GR /errorReport:prompt /MP /nologo /Zi 
        # May be needed(?): /Zc:wchar_t
    
        if Options.options.debugging:
            addl_flags = addl_flags + '/Od /Ob0 /RTC1'.split()
        else:
            addl_flags = addl_flags + '/O2 /Ob2'.split()

        for flags in [conf.env['CXXFLAGS'], conf.env['CFLAGS']]:
            for addl_flag in addl_flags:
                flags.append(addl_flag)
            flags.remove('/EHs')




# generate the cpp/hpp file in the same directory as the source
class Cl2Cpp:
    """Perform the same work as the opencv/cl2cpp.cmake command""" 
    
    CPP = """// This file is auto-generated. Do not edit!

#include \"precomp.hpp\"
#include \"{0}\"

namespace cv
{{
namespace ocl
{{
{1}

"""

    HPP = """// This file is auto-generated. Do not edit!

#include \"opencv2/core/ocl.hpp\"
#include \"opencv2/core/ocl_genbase.hpp\"
#include \"opencv2/core/opencl/ocl_defs.hpp\"

namespace cv
{{
namespace ocl
{{
{0}

"""

    @staticmethod
    def gen_source_name(module_name, ext=''):
        ocl_name_root = 'opencl_kernels_{}'.format(module_name)
        return ocl_name_root + ext

    @staticmethod
    def find_cl_source(source_dir):
        return [cl_file for cl_file in recursiveGlob(source_dir, ['*.cl'])]
    
    def __init__(self, module_name, source_dir):

        self.module_name = module_name
        self.source_dir  = source_dir

        ocl_name_root = Cl2Cpp.gen_source_name(module_name)
        self.output_hpp_name = ocl_name_root + '.hpp'
        self.output_cpp_name = ocl_name_root + '.cpp'

        if module_name == 'ocl':
            self.new_mode = False
            nested_namespace_start = ''
            nested_namespace_end   = ''
        else:
            self.new_mode = True
            nested_namespace_start = 'namespace {}\n{{'.format(module_name)
            nested_namespace_end   = '}'
        

        self.cpp_str = Cl2Cpp.CPP.format(self.output_hpp_name, nested_namespace_start)
        self.hpp_str = Cl2Cpp.HPP.format(nested_namespace_start)
        
        cl_files = Cl2Cpp.find_cl_source(source_dir)
        cl_files.sort()
        for cl_file in cl_files:
            self._generate_source_for_file(cl_file)

        self.cpp_str = self.cpp_str + "}}\n{0}}}\n".format(nested_namespace_end)
        self.hpp_str = self.hpp_str + "}}\n{0}}}\n".format(nested_namespace_end)


    def generate(self):
        # write out the source files
        with open(os.path.join(self.source_dir, self.output_hpp_name), 'w') as f:
            f.write(self.hpp_str)
        with open(os.path.join(self.source_dir, self.output_cpp_name), 'w') as f:
            f.write(self.cpp_str)
            

    def _generate_source_for_file(self, cl_file):
        with open(cl_file, 'r') as f:
            lines = f.read()
        

        cl_filename = os.path.splitext(os.path.basename(cl_file))[0]

        lines = lines.replace('\r', '')
        lines = lines + '\n' # not sure why, but it's there
        lines = lines.replace('\t', '  ')

        # was a speed problem
        multiline_comment = re.compile("""\/\*
                                          (?:[^*]\/|\*[^\/]|[^*\/])*
                                          \*\/
                                       """, re.X)
        

        lines = re.sub(multiline_comment,                    '',   lines)  # multiline comments
        lines = re.sub('\/\*(?:[^\n])*\*\/',                 '',   lines)  # single-line comments
        lines = re.sub('[ ]*\/\/[^\n]*\n',                   '\n', lines)  # single-line comments
        lines = re.sub('\n[ ]*(?:\n[ ]*)*',                  '\n', lines)  # empty lines & leading whitespace
        lines = re.sub('^\n',                                '',   lines)  # leading new line
        
        lines = lines.replace('\\', '\\\\') 
        lines = lines.replace('\"', '\\\"')
        lines = lines.replace('\n', '\\n\"\n\"')

        lines = re.sub('\"$', '', lines)

        # hash the lines
        lines_hash = md5.md5(lines).hexdigest()

        # assemble the template declarations
        str_cpp_decl = "const struct ProgramEntry {cl_filename}={{\"{cl_filename}\",\n\"{lines}, \"{hash}\"}};\n"
        str_hpp_decl = "extern const struct ProgramEntry {cl_filename};\n"
        if self.new_mode:
            str_cpp_decl = str_cpp_decl + "ProgramSource {cl_filename}_oclsrc({cl_filename}.programStr);\n"
            str_hpp_decl = str_hpp_decl + "extern ProgramSource {cl_filename}_oclsrc;\n"

        # fill in with the replacments
        replacement_dict = {'cl_filename': cl_filename, 'lines' : lines, 'hash': lines_hash }
        str_cpp_decl = str_cpp_decl.format(**replacement_dict)
        str_hpp_decl = str_hpp_decl.format(**replacement_dict)

        # append to the main string
        self.cpp_str = self.cpp_str + str_cpp_decl
        self.hpp_str = self.hpp_str + str_hpp_decl


@feature('add_targets')
@before_method('add_targets')
def generate_opencl_sources(self):
    #import ipdb; ipdb.set_trace()

    prefix = 'opencl_kernels_'

    cl_tgts = [tgt for tgt in self.targets_to_add
               if isinstance(tgt, str) and tgt.startswith(prefix)]

    # TODO: test for existence!
    for cl_tgt in cl_tgts:
        opencv_module = cl_tgt.replace(prefix, '')
        out_dir_node  = self.path.make_node(os.path.join(sourcepath, 'modules', opencv_module, 'src'))
        cl2cpp = Cl2Cpp(opencv_module, out_dir_node.abspath())
        cl2cpp.generate()


def opencv_generate_modules_header(conf):
    modules_header_dir = conf.path.make_node(join(sourcepath, 'opencv2'))
    modules_header_dir.mkdir()
    defs = dict(('HAVE_OPENCV_{0}'.format(x.upper()), '')
                for x in opencv_modules.split())
    makeHeaderFile(conf.bldnode.abspath(),
                   guard='__OPENCV2_MODULES_HPP__',
                   chmod=None,
                   defs=defs, undefs=None,
                   path=modules_header_dir,
                   output='opencv_modules.hpp')


def opencv_generate_version_string_inc(task):

    tgt = task.outputs[0]
    output = ''
    for key in ['CC', 'CXX', 'CFLAGS', 'CXXFLAGS', 'LINKFLAGS']:
        values = task.env[key]
        output = output + '"{}  {}\\n"\n'.format(key, repr(values))

    # write a string to it
    tgt.write(output)
        


def options(opt):
    opt.add_option('--with-opencv-home', action='store', dest='opencv_home',
                   help='Specify the OpenCV Home - where the OpenCV library is installed')

    opt.add_option('--disable-opencv', action='store_false', dest='enable_opencv',
                   help='will not build the opencv library')

    opt.add_option('--enable-opencv', action='store_true',
                   default=True, help='will build the opencv library if not found on the system (default)')

    opt.add_option('--build-opencv', action='store_true', dest="build_opencv",
                   help='force building opencv library from scratch',
                   default=os.path.exists(join(opt.path.abspath(), zipfile)))

    opt.add_option('--nobuild-opencv', action='store_false', dest="build_opencv",
                   help='force not building opencv library from scratch')

def configure(conf):    
    if Options.options.enable_opencv:
        if Options.options.opencv_home:
           pass 
        elif Options.options.build_opencv:
            # Build is off by default when zipfile not found, fail if forced on
            abszipfilepath   = join(conf.path.abspath(), zipfile)
            abszipsourcepath = join(conf.path.abspath(), sourcepath)
            if not os.path.exists(abszipfilepath):
                conf.fatal('Missing libopencv zipfile')
            
            # callback function to check for all #defines used by the opencv driver

            # status
            conf.env['MAKE_OPENCV'] = True
            conf.msg('Building local lib', 'opencv')
            
            # unzip archive
            if not os.path.exists(abszipsourcepath):
                with ZipFile(abszipfilepath, 'r') as opencvzipfile:
                    opencvzipfile.extractall(conf.path.abspath())

            # write the configuration file and set up build flags
            # TODO: write this into sourcedir
            # TODO: 
            #driverNode = conf.path.make_node(sourcepath)

            conf.setenv('%s_config_env' % 'opencv', conf.env.derive())
            conf.env['define_key'] = []

            opencv_set_defines(conf, Options.platform)
            #writeConfig(conf, opencv_set_defines, 'opencv', outfile='cvconfig.h', path=sourcepath,
            #            feature=None) #'makeHeader'

            conf.setenv('')

            # Generate the module configuration header
        
            opencv_generate_modules_header(conf)
        else:
            pass
        conf.env['HAVE_OPENCV'] = True




def build(bld):
    variant = bld.env['VARIANT']
    env = bld.all_envs[variant]
    if not 'MAKE_OPENCV' in env:
        return

    # Generate the version string header
    gen_version_string = 'gen_version_string'
    bld(name   = gen_version_string,
        rule   = opencv_generate_version_string_inc,
        target = bld.path.make_node(join(sourcepath, 'modules', 'core', 'version_string.inc')),
        always = True)

    def build_opencv_module(name, module_deps=[]):
        base_uselib       = 'THREAD DL RT'
        base_uselib_check = 'ZIP'
        includes_dir =  [join(sourcepath, 'modules', nm, 'include') for nm in [name] + module_deps] + \
                        [join(sourcepath, 'modules', 'core'), sourcepath]
        source_dir   = join(sourcepath, 'modules', name, 'src')
        module_deps_canon = ['opencv_' + x for x in module_deps]

        # see if there are any cl depends and add them to the build
        source_node = bld.path.make_node(source_dir)
        #exts = ['.hpp', '.cpp'] if len(Cl2Cpp.find_cl_source(source_node.abspath())) > 0 else []
        #targets_to_add = [root_source_name + ext for ext in exts]

        #print targets_to_add
        #if len(exts) > 0:

        # depend on the version string
        targets_to_add = [gen_version_string]
        if len(Cl2Cpp.find_cl_source(source_node.abspath())):
            root_source_name = Cl2Cpp.gen_source_name(name) 
            bld(name = root_source_name)
            targets_to_add.append(root_source_name)

        bld.module(name='opencv_%s' % name, env=env, uselib=base_uselib,
                   uselib_check=base_uselib_check,
                   includes=includes_dir,
                   version=version,
                   source_dir=source_dir,
                   module_deps=module_deps_canon,
                   targets_to_add=targets_to_add)

    
    build_opencv_module('hal')
    build_opencv_module('core', module_deps='hal'.split())
 

def distclean(context):
    # remove the untarred directories
    dirs = filter(lambda x: exists(join(context.path.abspath(), x)), 
                  [sourcepath])
    for d in dirs:
        try:
            shutil.rmtree(join(context.path.abspath(), d), ignore_errors=True)
        except:{}
