import os, sys, shutil
import re
from waflib import Options, Utils
from waflib.Utils import to_list as listify
from build import getPlatform, writeConfig, makeHeaderFile, listToTuple, recursiveGlob, unzipper
from os.path import join, exists, dirname, basename
from zipfile import ZipFile
import types
import md5
from collections import OrderedDict
from waflib.TaskGen import feature, before_method


version    = 'opencv-3.0.0-rc1'
sourcepath = '%s' % version
zipfile    = '%s.zip' % version

config_env = '%s_config_env' % 'opencv'


# ORDER MATTERS!
opencv_modules = """hal core flann imgproc ml photo video imgcodecs shape videoio
                    highgui objdetect superres ts features2d calib3d stitching videostab"""


opencv_module_dependencies = {
    'core'        : { 'module_deps':'hal' },
    'flann'       : { 'module_deps':'hal core' },
    'imgproc'     : { 'module_deps':'hal core' },
    'ml'          : { 'module_deps':'hal core' },
    'photo'       : { 'module_deps':'hal core imgproc' },
    'video'       : { 'module_deps':'hal core imgproc' },
    'imgcodecs'   : { 'module_deps':'hal core imgproc', 'uselib':'JPEG'},
    'shape'       : { 'module_deps':'hal core imgproc video' },
    'videoio'     : { 'module_deps':'hal core imgproc video imgcodecs' },
    'highgui'     : { 'module_deps':'hal core imgproc imgcodecs videoio', 'uselib':'SOCKET'},
    'objdetect'   : { 'module_deps':'hal core imgproc ml imgcodecs videoio highgui' },
    'superres'    : { 'module_deps':'hal core imgproc imgcodecs video videoio' },
    'ts'          : { 'module_deps':'hal core imgproc imgcodecs videoio highgui' },
    'features2d'  : { 'module_deps':'hal core flann imgproc ml imgcodecs videoio highgui' },
    'calib3d'     : { 'module_deps':'hal core flann imgproc ml imgcodecs videoio highgui features2d' },
    'stitching'   : { 'module_deps':'hal core flann imgproc ml imgcodecs videoio highgui objdetect features2d calib3d' },
    'videostab'   : { 'module_deps':'hal core flann imgproc ml photo video imgcodecs videoio highgui features2d calib3d' },
}


win32_regex = 'win32'
linux_regex = r'.*-.*-linux-.*|i686-pc-.*|linux'


def find_source(source_dir, glob):
    return [f for f in recursiveGlob(source_dir, listify(glob))]

def unique(x):
    """Ordered unique list"""
    return list(OrderedDict.fromkeys(x)) 

class OpenCVModuleDependencies:
    uselib_deps = {
        win32_regex : {
            'videoio' : 'vfw32'.split(), 
            'highgui' : 'comctl32 gdi32 ole32 setupapi user32 advapi32 comdlg32'.split(), # ws2_32 == SOCKET
        },
        linux_regex : {
        }
    }

    @staticmethod
    def platform_deps(sys_platform, modules=None, lc=False):
        deps = OpenCVModuleDependencies.uselib_deps 
        if modules is not None:
            modules = listify(modules)
        out = []
        for regex in deps:
            if re.match(regex, sys_platform):
                if modules is None:
                    for values in deps[regex].values():
                        out = out + values
                else:
                    for module in modules:
                        if deps[regex].has_key(module):
                            out = deps[regex][module]
                break
        return out if lc else [dep.upper() for dep in out] #uppercase-ize


class OpenCVCompilerConfig:
    """Namespace class for compiler definitions"""

    #-TODO:  march=i686 -mfpmath=sse use these???
    # -Wno-narrowing  
    gcc_compiler_flags    = """-fdiagnostics-show-option -ffunction-sections -fomit-frame-pointer -fPIC -fsigned-char
                                -fvisibility=hidden -msse -msse2 -msse3 -W -Wall -Werror=address -Werror=format-security 
                                -Werror=non-virtual-dtor -Werror=return-type -Werror=sequence-point -Wformat -Winit-self
                                -Wmissing-declarations -Wpointer-arith -Wshadow -Wundef""".split()
    # -finput-charset=UTF-16BE

    # -Wno-delete-non-virtual-dtor 
    gcc_compiler_cxxflags = gcc_compiler_flags + '-fvisibility-inlines-hidden -Wsign-promo'.split()
    gcc_compiler_cflags   = gcc_compiler_flags + '-Wmissing-prototypes -Wstrict-prototypes'.split()

    gcc_release_compiler_flags = '-O2'.split()
    gcc_debug_compiler_flags   = '-g -O0'.split()


    # Already done/skippable: /W4 /GR /errorReport:prompt /MP /nologo /Zi 
    # May be needed(?): /Zc:wchar_t
    msvc_compiler_flags    = '/EHa /fp:precise /Gd /Gm- /GS /Gy /Oi /TP /WX- /Zc:forScope /bigobj /wd4324 /wd4251'.split()
    msvc_debug_compiler_flags   = '/Od /Ob0 /RTC1'.split()
    msvc_release_compiler_flags = '/O2 /Ob2'.split()

    msvc_c_cxx_compiler_config = {
        'debug': {
            '+': msvc_compiler_flags + msvc_debug_compiler_flags,
            '-': '/EHs'.split(),
        },
        'release':{
            '+': msvc_compiler_flags + msvc_release_compiler_flags,
            '-': '/EHs'.split(),
        },
    }

    gcc_icc_compiler_config = {
        'CFLAGS': {
            'debug': {
                '+': gcc_compiler_cflags + gcc_debug_compiler_flags,
             },
            'release': {
                '+': gcc_compiler_cflags + gcc_release_compiler_flags,
             }, 
        },
        'CXXFLAGS': {
            'debug': {
                '+': gcc_compiler_cxxflags + gcc_debug_compiler_flags,
             },
            'release': {
                '+': gcc_compiler_cxxflags + gcc_release_compiler_flags,
             }, 
        },
        'DEFINES': {
            'debug':   'DEBUG _DEBUG'.split(),
            'release': 'NDEBUG'.split(),
        },
    }

    msvc_base_compiler_defines = """WIN32 _CRT_NONSTDC_NO_DEPRECATE _CRT_SECURE_NO_DEPRECATE 
                                    _VARIADIC_MAX=10 _WINDOWS""".split() # '_MBCS'

    msvc_compiler_config = {
        'CFLAGS': msvc_c_cxx_compiler_config,
        'CXXFLAGS': msvc_c_cxx_compiler_config,
        'DEFINES': {
            'debug': { 
                '+': msvc_base_compiler_defines + '_DEBUG'.split(),
                '-': 'WIN32_LEAN_AND_MEAN'.split(),
            },
            'release': {
                '+': msvc_base_compiler_defines + 'NDEBUG'.split(),
                '-': 'WIN32_LEAN_AND_MEAN'.split(),
            }
        },
        'libs': OpenCVModuleDependencies.platform_deps(getPlatform(default=Options.platform))
    }

    compiler_config = {
        'gcc':  gcc_icc_compiler_config,
        'icc':  gcc_icc_compiler_config,
        'msvc': msvc_compiler_config,
    }

    @staticmethod
    def configure(conf, debugging):
        build_type      = 'debug' if debugging else 'release'
        compiler_config = OpenCVCompilerConfig.compiler_config[conf.env['COMPILER_CC']]
        for key in ['DEFINES', 'CXXFLAGS', 'CFLAGS']:
            overrides = compiler_config[key][build_type]
            clone = list(conf.env[key])
            if isinstance(overrides, dict):
                if overrides.has_key('+'):
                    for override in overrides['+']:
                        clone.append(override)
                if overrides.has_key('-'):
                    for override in overrides['-']:
                        clone.remove(override)
            else:
                for override in overrides:
                    clone.append(override)
            # replace the values in our derived environment
            conf.env[key] = clone

        # use by all versions
        conf.env.DEFINES.append("__OPENCV_BUILD=1")

    @staticmethod
    def configure_libs(conf):
        compiler_config = OpenCVCompilerConfig.compiler_config[conf.env['COMPILER_CC']]
        if compiler_config.has_key('libs'):
            libs = compiler_config['libs']
            for lib in libs:
                conf.check_cc(lib=lib.lower(), uselib_store=lib)



class CVConfigHGenerator:
    """Class for generated cvconfig.h"""

    platform_defines = {
        win32_regex : {
            'HAVE_WIN32UI': '',
            'HAVE_VFW':  '',
        },
        linux_regex : {
            # TODO: different options for linux??
            # Should we try to detect what's on the
            # the system?? gtk/gstreamer/xine?
            'HAVE_CAMV4L2': '',
        }
    }

    core_vars = {
        'OPENCV_CUDA_ARCH_BIN' : '',
        'OPENCV_CUDA_ARCH_FEATURES' : '',
        'OPENCV_CUDA_ARCH_PTX' : '',
    }

    core_defines = {
        'HAVE_INTTYPES_H': lambda conf: conf.check_cc(header_name='inttypes.h', mandatory=False),
        'WORDS_BIGENDIAN': lambda conf: conf.check_endianness() != 'little',
        # TODO: can we link our version of this?
        #'HAVE_JPEG': ''
    }

    define_regex     = re.compile(r'#cmakedefine\s+(.*)')
    define_rep_regex = r'#cmakedefine\s+\b%s\b'
    var_regex        = re.compile(r'\${(.*)}')
    var_rep_regex    = r'\${%s}'

    def __init__(self, template_file):
        with open(template_file, 'r') as f:
            self.template_str = f.read()

        # find subsitution candidates
        possible_defines = {}
        def_iter = self.define_regex.finditer(self.template_str)
        for pos_def in def_iter:
            possible_defines[pos_def.group(1)] = None
        self.possible_defines = possible_defines

        # find subsitution candidates
        possible_vars = {}
        var_iter = self.var_regex.finditer(self.template_str)
        for pos_var in var_iter:
            possible_vars[pos_var.group(1)] = None
        self.possible_vars = possible_vars 


    def write(self, path, def_set, var_set):
        def_set_merge = CVConfigHGenerator.merge_dict(self.possible_defines, def_set)
        var_set_merge = CVConfigHGenerator.merge_dict(self.possible_vars, var_set)

        # replace #cmakedefine
        out_str = self.template_str
        for define, value in def_set_merge.iteritems():
            if value is None:
                out_str = re.sub(self.define_rep_regex % define,
                                 r'/* #undef %s */' % define, out_str)
            else:
                out_str = re.sub(self.define_rep_regex % define,
                                 r'#define %s %s' % (define, value), out_str)
        

        # replace ${var}
        for var, value in var_set_merge.iteritems():
            if value is None:
                out_str = re.sub(self.var_rep_regex % var, '', out_str)
            else:
                out_str = re.sub(self.var_rep_regex % var, value, out_str)
                
        # dump the contents
        with open(path, 'w') as f:
            f.write(out_str)

    @staticmethod
    def merge_dict(d1, d2):
        if d1:
            out = d1.copy()
            out.update(d2)
        return out

    @staticmethod
    def partition_defines(conf, sys_platform, compiler):
        """Separate defines from undefines"""

        special_defines = {}
        for regex in CVConfigHGenerator.platform_defines.keys():
            if re.match(regex, sys_platform):
                special_defines = CVConfigHGenerator.platform_defines[regex]
                break

        # merge defines into a single dictionary
        defines = special_defines.copy()
        defines.update(CVConfigHGenerator.core_defines)
        
        # partition into defs, undefs
        defs = {}

        remap_bool = lambda val: '' if val is not None else None
        for define, value in defines.iteritems():
            is_def = True
            if isinstance(value, types.FunctionType):
                result = value(conf)
                is_def = result
            else:
                # what was specified is what will go in
                result = value
            if is_def:
                defs[define] = remap_bool(result)
        
        return defs

    @staticmethod
    def generate(conf, sys_platform):
        """Generate cvconfig.h"""

        # Fill out cvconfig.h
        defs = CVConfigHGenerator.partition_defines(conf, sys_platform, conf.env['COMPILER_CC'])
        template_file = conf.path.make_node(join(sourcepath, 'cmake',
                                                 'templates', 'cvconfig.h.in'))
        gen = CVConfigHGenerator(template_file.abspath())
        gen.write(conf.path.make_node(join(sourcepath, 'cvconfig.h')).abspath(),
                  defs, CVConfigHGenerator.core_vars)


# generate the cpp/hpp file in the same directory as the source
class Cl2Cpp:
    """Perform the same work as the opencv/cl2cpp.cmake command""" 
    
    CPP = """// This file is auto-generated. Do not edit!

#include \"precomp.hpp\"
#include \"{0}\"

namespace cv
{{
namespace ocl
{{
{1}

"""

    HPP = """// This file is auto-generated. Do not edit!

#include \"opencv2/core/ocl.hpp\"
#include \"opencv2/core/ocl_genbase.hpp\"
#include \"opencv2/core/opencl/ocl_defs.hpp\"

namespace cv
{{
namespace ocl
{{
{0}

"""

    @staticmethod
    def gen_source_name(module_name, ext=''):
        ocl_name_root = 'opencl_kernels_{}'.format(module_name)
        return ocl_name_root + ext

    def __init__(self, module_name, source_dir):

        self.module_name = module_name
        self.source_dir  = source_dir

        ocl_name_root = Cl2Cpp.gen_source_name(module_name)
        self.output_hpp_name = ocl_name_root + '.hpp'
        self.output_cpp_name = ocl_name_root + '.cpp'

        if module_name == 'ocl':
            self.new_mode = False
            nested_namespace_start = ''
            nested_namespace_end   = ''
        else:
            self.new_mode = True
            nested_namespace_start = 'namespace {}\n{{'.format(module_name)
            nested_namespace_end   = '}'
        

        self.cpp_str = Cl2Cpp.CPP.format(self.output_hpp_name, nested_namespace_start)
        self.hpp_str = Cl2Cpp.HPP.format(nested_namespace_start)
        
        cl_files = find_source(source_dir, '*.cl')
        cl_files.sort()
        for cl_file in cl_files:
            self._generate_source_for_file(cl_file)

        self.cpp_str = self.cpp_str + "}}\n{0}}}\n".format(nested_namespace_end)
        self.hpp_str = self.hpp_str + "}}\n{0}}}\n".format(nested_namespace_end)


    def generate(self):
        # write out the source files
        with open(join(self.source_dir, self.output_hpp_name), 'w') as f:
            f.write(self.hpp_str)
        with open(join(self.source_dir, self.output_cpp_name), 'w') as f:
            f.write(self.cpp_str)
            

    def _generate_source_for_file(self, cl_file):
        with open(cl_file, 'r') as f:
            lines = f.read()
        

        cl_filename = os.path.splitext(os.path.basename(cl_file))[0]

        lines = lines.replace('\r', '')
        lines = lines + '\n' # not sure why, but it's there
        lines = lines.replace('\t', '  ')

        # was a speed problem
        multiline_comment = re.compile("""\/\*
                                          (?:[^*]\/|\*[^\/]|[^*\/])*
                                          \*\/
                                       """, re.X)
        

        lines = re.sub(multiline_comment,    '',   lines)  # multiline comments
        lines = re.sub('\/\*(?:[^\n])*\*\/', '',   lines)  # single-line comments
        lines = re.sub('[ ]*\/\/[^\n]*\n',   '\n', lines)  # single-line comments
        lines = re.sub('\n[ ]*(?:\n[ ]*)*',  '\n', lines)  # empty lines & leading whitespace
        lines = re.sub('^\n',                '',   lines)  # leading new line
        
        lines = lines.replace('\\', '\\\\') 
        lines = lines.replace('\"', '\\\"')
        lines = lines.replace('\n', '\\n\"\n\"')

        lines = re.sub('\"$', '', lines)

        # hash the lines
        lines_hash = md5.md5(lines).hexdigest()

        # assemble the template declarations
        str_cpp_decl = "const struct ProgramEntry {cl_filename}={{\"{cl_filename}\",\n\"{lines}, \"{hash}\"}};\n"
        str_hpp_decl = "extern const struct ProgramEntry {cl_filename};\n"
        if self.new_mode:
            str_cpp_decl = str_cpp_decl + "ProgramSource {cl_filename}_oclsrc({cl_filename}.programStr);\n"
            str_hpp_decl = str_hpp_decl + "extern ProgramSource {cl_filename}_oclsrc;\n"

        # fill in with the replacments
        replacement_dict = {'cl_filename': cl_filename, 'lines' : lines, 'hash': lines_hash }
        str_cpp_decl = str_cpp_decl.format(**replacement_dict)
        str_hpp_decl = str_hpp_decl.format(**replacement_dict)

        # append to the main string
        self.cpp_str = self.cpp_str + str_cpp_decl
        self.hpp_str = self.hpp_str + str_hpp_decl


@feature('add_targets')
@before_method('add_targets')
def generate_opencl_sources(self):

    prefix = 'opencl_kernels_'

    cl_tgts = [tgt for tgt in self.targets_to_add
               if isinstance(tgt, str) and tgt.startswith(prefix)]

    # TODO: test for existence!
    for cl_tgt in cl_tgts:
        opencv_module = cl_tgt.replace(prefix, '')
        out_dir_node  = self.path.make_node(join(sourcepath, 'modules', opencv_module, 'src'))
        cl2cpp = Cl2Cpp(opencv_module, out_dir_node.abspath())
        cl2cpp.generate()


def opencv_generate_modules_header(conf):
    modules_header_dir = conf.path.make_node(join(sourcepath, 'opencv2'))
    modules_header_dir.mkdir()
    defs = dict(('HAVE_OPENCV_{0}'.format(x.upper()), '')
                for x in opencv_modules.split())
    makeHeaderFile(conf.bldnode.abspath(),
                   guard='__OPENCV2_MODULES_HPP__',
                   chmod=None,
                   defs=defs, undefs=None,
                   path=modules_header_dir,
                   output='opencv_modules.hpp')


def opencv_generate_version_string_inc(task):

    tgt = task.outputs[0]
    output = ''
    for key in ['CC', 'CXX', 'CFLAGS', 'CXXFLAGS', 'LINKFLAGS']:
        values = task.env[key]
        output = output + '"{}  {}\\n"\n'.format(key, repr(values))

    # write a string to it
    tgt.write(output)


class OpenCVSourceFilter:
    videoio_base_sources = 'cap.cpp cap_images.cpp cap_mjpeg_encoder.cpp cap_mjpeg_decoder.cpp'.split()
    highgui_base_sources = 'window.cpp'.split()

    #TODO: videoio/highgui link flags
    # videoio "/NODEFAULTLIB:atlthunk.lib /NODEFAULTLIB:atlsd.lib /NODEFAULTLIB:libcmt.lib /DEBUG"
    # highgui  same
    filters = {
        'videoio': {
            win32_regex : videoio_base_sources + 'cap_cmu.cpp cap_vfw.cpp'.split(),
            linux_regex : videoio_base_sources + 'cap_v4l.cpp'.split(), 
        },
        'highgui': {
            win32_regex : highgui_base_sources + 'window_w32.cpp'.split(),
            linux_regex : highgui_base_sources + ''.split(),
        }
    }

    @staticmethod
    def create_inverted_source_filter(good_files, source_dir):
        # find all files
        all_files = [cpp_file for cpp_file in recursiveGlob(source_dir, ['*.cpp'])] + \
                    [c_file for cl_file in recursiveGlob(source_dir, ['*.c'])]

        # remove path prefix
        all_files = [os.path.basename(f) for f in all_files]

        # subtract good files
        bad_files = set(all_files) - set(good_files)

        return " ".join(bad_files)

    def __init__(self, sys_platform, module, source_dir):
        self.source_filter = ''
        if self.filters.has_key(module):
            filters = self.filters[module]
            for regex in filters.keys():
                if re.match(regex, sys_platform):
                    good_files = filters[regex]
                    self.source_filter = \
                        OpenCVSourceFilter.create_inverted_source_filter(good_files,
                                                                         source_dir)
                    break
    
    def get(self):
        return self.source_filter



canonicalize = lambda md: 'opencv_' + md if isinstance(md, str) else ['opencv_' + x for x in md]

def build_opencv(bld, env, source_files):
    """Build step implementation"""
    sys_platform = getPlatform(default=Options.platform)

    # Generate the version string header
    gen_version_string = 'gen_version_string'
    bld(name   = gen_version_string,
        rule   = opencv_generate_version_string_inc,
        target = bld.path.make_node(join(sourcepath, 'modules', 'core', 'version_string.inc')),
        always = True)


    inc          = lambda md: [join(sourcepath, 'modules', nm, 'include') for nm in md] 
    pdeps        = lambda deps: OpenCVModuleDependencies.platform_deps(sys_platform, deps)
    
    base_uselib       = 'THREAD DL RT'.split() 
    base_uselib_check = 'ZIP' # string, not list expected
    core_module       = join(sourcepath, 'modules', 'core')
    base_includes     = [sourcepath, core_module]


    if env['install_headers']:
        bld(features='install_tgt', pattern='*.h opencv2/*.hpp opencv2/*.h', 
            dir=bld.path.make_node(sourcepath), install_path=env['install_includedir'],
            name='CVCONFIG_H_INSTALL')
        bld(features='install_tgt', pattern='**/*.h **/*.hpp', 
            dir=bld.path.make_node(join(sourcepath, 'include')),
            install_path=env['install_includedir'],
            name='OPENCV_HEADER_INSTALL')


    all_libs      = []
    all_test_perf = []
    all_apps      = []

    def build_opencv_module(name, module_deps=[], uselib=[], extra_targets=[]):
        if isinstance(module_deps, str):
            module_deps = module_deps.split()
        if isinstance(uselib, str):
            uselib = uselib.split()

        src  = lambda nm: join(sourcepath, 'modules', nm, 'src') 
        perf = lambda nm: join(sourcepath, 'modules', nm, 'perf') 
        test = lambda nm: join(sourcepath, 'modules', nm, 'test') 

        uselib_platform   = OpenCVModuleDependencies.platform_deps(sys_platform, name)
        uselib            = base_uselib + uselib + uselib_platform

        source_dir        = src(name)
        source_node       = bld.path.make_node(source_dir)
        sources           = source_node.ant_glob('**/*.cpp') + source_node.ant_glob('**/*.c') 

        source_filter     = OpenCVSourceFilter(sys_platform, name, source_node.abspath()).get().split()
        includes_dir      = inc([name] + module_deps) + base_includes + [source_dir]

        module_deps_canon = canonicalize(module_deps)

        # depend on the version string
        targets_to_add = [gen_version_string] + extra_targets

        # see if there are any cl depends and add them to the build
        if len(find_source(source_node.abspath(), '*.cl')):
            root_source_name = Cl2Cpp.gen_source_name(name) 
            bld(name = root_source_name)
            targets_to_add.append(root_source_name)

        if env['install_headers']:
            htgt = '{}_INCLUDE_INSTALL'.format(canonicalize(name).upper())
            bld(features='install_tgt', pattern='**/*.h **/*.hpp', 
                dir=bld.path.make_node(inc([name])), install_path=env['install_includedir'],
                name=htgt)
            targets_to_add.append(htgt)


        module_name = canonicalize(name)
        all_libs.append(module_name.upper())
        ocvlib = bld(features='c c%s add_targets' % env['LIB_TYPE'] or 'stlib',
                     includes=includes_dir,
                     export_includes=includes_dir,
                     target=module_name,
                     source=sources,
                     path=bld.path,
                     defines=env['DEFINES'],
                     uselib=uselib,
                     use=base_uselib_check.split() + [m.upper() for m in module_deps_canon],
                     env=env.derive(),
                     name=module_name.upper(),
                     targets_to_add=targets_to_add)
        ocvlib.source = [s for s in ocvlib.source if basename(str(s)) not in source_filter]

        if env['install_libs']:
            ocvlib.install_path = env['install_libdir']

        perf_deps = ['ts', name, 'imgcodecs', 'videoio', 'highgui'] + module_deps
        test_deps = perf_deps + ['imgproc']
        progs = {
            perf(name) : { 'deps': perf_deps,
                            'fmt': 'opencv_perf_{}'},
            test(name) : { 'deps': test_deps,
                            'fmt': 'opencv_test_{}'},
        }

        for src_dir, info in progs.iteritems():
            if bld.path.find_dir(src_dir): 
                deps = info['deps']
                pname = info['fmt'].format(name)
                all_test_perf.append(pname)
                bld.program_helper(name=pname, env=env,
                                   use=uselib + base_uselib_check.split() + pdeps(deps),
                                   uselib_local=[m.upper() for m in canonicalize(deps)],
                                   includes=inc(deps) + [sourcepath],
                                   source_dir=src_dir)



    # add source installation to most core module
    hal_extra = []
    if env['install_source']:
        source_files.append(zipfile)
        hal_extra.append('OPENCV_SOURCE_INSTALL')
    if env['install_headers']:
        hal_extra.append('CVCONFIG_H_INSTALL')
        hal_extra.append('OPENCV_HEADER_INSTALL')

    build_opencv_module('hal', extra_targets=hal_extra) # has no dependencies
    for module, module_info in opencv_module_dependencies.iteritems():
        build_opencv_module(module, **module_info)
    

    def build_opencv_program(name, module_deps=[]):
        module_deps = listify(module_deps)
        appsource = join(sourcepath, 'apps', name)
        appname = canonicalize(name)
        all_apps.append(appname)
        bld.program_helper(name=appname, env=env,
                           use=base_uselib_check.split() + pdeps(module_deps),
                           uselib_local=[m.upper() for m in canonicalize(module_deps)],
                           includes=inc(module_deps) + base_includes + [join(sourcepath, 'include', 'opencv')],
                           source_dir=appsource)


    build_opencv_program('traincascade',  module_deps='hal core imgproc objdetect imgcodecs highgui calib3d features2d')
    build_opencv_program('createsamples', module_deps='hal core imgproc objdetect imgcodecs highgui calib3d features2d videoio')
    build_opencv_program('annotation',    module_deps='hal core highgui imgproc imgcodecs videoio')

    bld(name='opencv_all_libs',      features='add_targets', targets_to_add=all_libs)
    bld(name='opencv_all_test_perf', features='add_targets', targets_to_add=all_libs + all_test_perf)
    bld(name='opencv_all_apps',      features='add_targets', targets_to_add=all_libs + all_apps)
    bld(name='opencv_mega',          features='add_targets', targets_to_add=all_test_perf + all_apps + all_libs)



def opencv_configure_libs(conf, sys_platform, conf_params={}):
  # add platform deps
  OpenCVCompilerConfig.configure_libs(conf)

  for ocv_module_name in opencv_modules.split():
      opencv_lib = canonicalize(ocv_module_name)

      use = []
      for n in 'DL RT ZIP'.split():
          use += conf.env['LIB_' + n]
      libs = [opencv_lib]
      if opencv_module_dependencies.has_key(ocv_module_name):
          info = opencv_module_dependencies[ocv_module_name]
          if info.has_key('module_deps'):
              cdeps = canonicalize(info['module_deps'].split())
              cdeps.reverse() # link order is reverse of build order
              libs += cdeps
          if info.has_key('uselib'):
              for lib in info['uselib'].split():
                  use += conf.env['LIB_' + lib.upper()]

          # test for lib and *all* of its dependencies
          libs += (use + OpenCVModuleDependencies.platform_deps(sys_platform, ocv_module_name, lc=True))
          conf.check(lib=libs,
                     uselib_store=opencv_lib.upper(), 
                     header_name=join('opencv2', '{}.hpp'.format(ocv_module_name)),
                     use='THREAD',
                     msg='Checking for library {}'.format(opencv_lib),
                     mandatory=True,
                     **conf_params)


def options(opt):
    opt.add_option('--with-opencv-home', action='store', dest='opencv_home',
                   help='Specify the OpenCV Home - where the OpenCV library is installed')

    opt.add_option('--disable-opencv', action='store_false', dest='enable_opencv',
                   help='will not build the opencv library')

    opt.add_option('--enable-opencv', action='store_true',
                   default=True, help='will build the opencv library if not found on the system (default)')

    opt.add_option('--build-opencv', action='store_true', dest="build_opencv",
                   help='force building opencv library from scratch',
                   default=os.path.exists(join(opt.path.abspath(), zipfile)))

    opt.add_option('--nobuild-opencv', action='store_false', dest="build_opencv",
                   help='force not building opencv library from scratch')

def configure(conf):    
    if not Options.options.enable_opencv:
      return 
    sys_platform = getPlatform(default=Options.platform)

    if Options.options.opencv_home:
        if not Options.options.zip_home:
            conf.fatal('Using prebuilt opencv required prebuilt zlib')
        opencv_home = Options.options.opencv_home
        opencv_configure_libs(conf, sys_platform, conf_params={ 
            'libpath':  join(opencv_home, 'lib'),
            'includes': join(opencv_home, 'include'),
            'okmsg':    opencv_home,
        })
    elif Options.options.build_opencv:
        
        # Build is off by default when zipfile not found, fail if forced on
        abszipfilepath = join(conf.path.abspath(), zipfile)
        if not os.path.exists(abszipfilepath):
            conf.fatal('Missing libopencv zipfile')
        
        # status
        conf.env['MAKE_OPENCV'] = True
        conf.msg('Building local lib', 'opencv')
        
        # unzip archive
        unzipper(abszipfilepath, conf.path.abspath())

        # clean up opencv-3.0.0-rc1/modules/imgproc/src/hough.cpp
        bad_guy = conf.path.ant_glob('**/imgproc/src/hough.cpp')[0]
        bad_guy.write(bad_guy.read()[3:]) # has a bogus UTF-16 mark

        # these need to 'escape' private configuration
        # do this before, so that the new env (and everyone else
        # will inherit them
        OpenCVCompilerConfig.configure_libs(conf)

        # switch to another env for our private build settings
        conf.setenv(config_env, conf.env.derive())
        conf.env['define_key'] = []

        # Generate module configuration
        CVConfigHGenerator.generate(conf, sys_platform)
        OpenCVCompilerConfig.configure(conf, Options.options.debugging)
        opencv_generate_modules_header(conf)

        # change back to normal build context
        conf.setenv('')
    else:
        if Options.options.build_zip:
            conf.fatal('Using prebuilt opencv required prebuilt zlib')
        opencv_configure_libs(conf, sys_platform, )

    conf.env['HAVE_OPENCV'] = True




def build(bld):
    
    if bld.all_envs.has_key(config_env):
        # get compiler flags, etc
        env = bld.all_envs[config_env]
    else:
        env = bld.all_envs[bld.env['VARIANT']]

    source_files = []
    if 'MAKE_OPENCV' in env:
        build_opencv(bld, env, source_files)

    if env['install_source']:
        source_node = bld.path.make_node('source')
        bld.install_tgt(files=source_files,
                        dir=bld.path,
                        install_path=join('${PREFIX}', source_node.path_from(bld.path)),
                        relative_trick=True,
                        name='OPENCV_SOURCE_INSTALL')



def distclean(context):
    # remove the untarred directories
    dirs = filter(lambda x: exists(join(context.path.abspath(), x)), 
                  [sourcepath])
    for d in dirs:
        try:
            shutil.rmtree(join(context.path.abspath(), d), ignore_errors=True)
        except:{}



# vim: set ft=python :
